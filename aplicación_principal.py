# -*- coding: utf-8 -*-
"""Aplicaci칩n Principal

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1htNrQufzeEe2ImCkP1tqxKB3kBH8qIBB
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn import datasets
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score

# Configuraci칩n de la p치gina
st.set_page_config(page_title="Clasificaci칩n de Especies Iris", layout="wide")

# T칤tulo y descripci칩n
st.title("游꺚 Dashboard de Clasificaci칩n de Especies Iris")
st.markdown("""
Este proyecto implementa un flujo de trabajo de miner칤a de datos completo para clasificar flores Iris.
Utiliza un modelo de **Random Forest** para predecir la especie bas치ndose en las medidas de s칠palos y p칠talos.
""")

# --- 1. CARGA Y PREPROCESAMIENTO DE DATOS ---
@st.cache_data
def load_data():
    iris = datasets.load_iris()
    df = pd.DataFrame(data=iris.data, columns=iris.feature_names)
    df['species'] = iris.target
    df['species_name'] = df['species'].map({0: 'setosa', 1: 'versicolor', 2: 'virginica'})
    return df, iris.target_names

df, target_names = load_data()

# Divisi칩n de datos (Train/Test)
X = df.drop(['species', 'species_name'], axis=1)
y = df['species']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# --- 2. MODELADO (Random Forest) ---
# Entrenamos el modelo una vez al cargar la app
rf_model = RandomForestClassifier(n_estimators=100, random_state=42)
rf_model.fit(X_train, y_train)
y_pred = rf_model.predict(X_test)

# --- 3. BARRA LATERAL (Input del Usuario) ---
st.sidebar.header("游댌 Par치metros de Entrada")
st.sidebar.write("Ajusta las medidas para predecir la especie:")

def user_input_features():
    sepal_length = st.sidebar.slider('Sepal length (cm)', float(df.iloc[:,0].min()), float(df.iloc[:,0].max()), float(df.iloc[:,0].mean()))
    sepal_width = st.sidebar.slider('Sepal width (cm)', float(df.iloc[:,1].min()), float(df.iloc[:,1].max()), float(df.iloc[:,1].mean()))
    petal_length = st.sidebar.slider('Petal length (cm)', float(df.iloc[:,2].min()), float(df.iloc[:,2].max()), float(df.iloc[:,2].mean()))
    petal_width = st.sidebar.slider('Petal width (cm)', float(df.iloc[:,3].min()), float(df.iloc[:,3].max()), float(df.iloc[:,3].mean()))

    data = {'sepal length (cm)': sepal_length,
            'sepal width (cm)': sepal_width,
            'petal length (cm)': petal_length,
            'petal width (cm)': petal_width}
    features = pd.DataFrame(data, index=[0])
    return features

input_df = user_input_features()

# --- 4. PREDICCI칍N ---
st.subheader("1. Predicci칩n del Modelo")

# Realizar predicci칩n con los datos del usuario
prediction = rf_model.predict(input_df)
prediction_proba = rf_model.predict_proba(input_df)

# Mostrar resultados
col1, col2 = st.columns(2)
with col1:
    st.info(f"Especie Predicha: **{target_names[prediction][0].upper()}**")
with col2:
    st.write("Probabilidad de predicci칩n:")
    prob_df = pd.DataFrame(prediction_proba, columns=target_names)
    st.dataframe(prob_df.style.format("{:.2%}"))

# --- 5. M칄TRICAS DE EVALUACI칍N ---
st.subheader("2. M칠tricas del Modelo (Conjunto de Prueba)")
st.write("Rendimiento del modelo Random Forest en los datos de test separados (20%):")

acc = accuracy_score(y_test, y_pred)
prec = precision_score(y_test, y_pred, average='macro')
rec = recall_score(y_test, y_pred, average='macro')
f1 = f1_score(y_test, y_pred, average='macro')

m1, m2, m3, m4 = st.columns(4)
m1.metric("Accuracy", f"{acc:.2f}")
m2.metric("Precision", f"{prec:.2f}")
m3.metric("Recall", f"{rec:.2f}")
m4.metric("F1 Score", f"{f1:.2f}")

# --- 6. VISUALIZACI칍N 3D INTERACTIVA (CR칈TICO) ---
st.subheader("3. Visualizaci칩n 3D: Dataset + Tu Muestra")
st.markdown("Este gr치fico muestra la distribuci칩n de las especies. **El punto rojo grande** representa los valores que acabas de ingresar.")

# Preparamos los datos para el gr치fico 3D
# 1. Dataset Original
plot_data = df.copy()
plot_data['Type'] = 'Dataset Original'
plot_data['Size'] = 2  # Tama침o normal

# 2. Dato del Usuario
user_point = input_df.copy()
user_point['species_name'] = 'INPUT USUARIO' # Etiqueta especial
user_point['Type'] = 'Input Usuario'
user_point['Size'] = 10 # Tama침o grande para destacar

# Concatenamos (Nota: 'species' columna num칠rica no es necesaria para el plot visual si usamos species_name)
combined_df = pd.concat([plot_data, user_point], ignore_index=True)

# Crear gr치fico 3D con Plotly
fig_3d = px.scatter_3d(combined_df,
    x='sepal length (cm)',
    y='sepal width (cm)',
    z='petal length (cm)',
    color='species_name',
    symbol='Type',
    size='Size',
    size_max=15, # Ajuste visual
    opacity=0.8,
    title='Espacio 3D: Sepal Length vs Sepal Width vs Petal Length',
    color_discrete_map={'setosa': 'blue', 'versicolor': 'green', 'virginica': 'purple', 'INPUT USUARIO': 'red'}
)
st.plotly_chart(fig_3d, use_container_width=True)

# --- 7. EDA ADICIONAL ---
st.subheader("4. An치lisis Exploratorio de Datos (EDA)")

tab1, tab2 = st.tabs(["Histogramas", "Matriz de Dispersi칩n"])

with tab1:
    st.write("Distribuci칩n de las caracter칤sticas por especie:")
    feature_to_plot = st.selectbox("Selecciona caracter칤stica:", df.columns[:-2])
    fig_hist = px.histogram(df, x=feature_to_plot, color="species_name", barmode="overlay")
    st.plotly_chart(fig_hist, use_container_width=True)

with tab2:
    st.write("Relaci칩n entre pares de variables:")
    # Usamos seaborn para pairplot est치tico, es muy claro para Iris
    fig_sns = sns.pairplot(df, hue="species_name", markers=["o", "s", "D"])
    st.pyplot(fig_sns)

st.markdown("---")
st.caption("Proyecto Final de Miner칤a de Datos - Desarrollado con Streamlit")